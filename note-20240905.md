# Desugaring and Name Resolution
## In Rust
I came across [this thread](https://x.com/CohenArthurDev/status/1830989356183503247) from the developer of the GCC codegen backend for `rustc`, and I thought it made an important point about desugaring and name resolution.

In the Rust case, desugaring occurs prior to name resolution. Since you need to be able to refer to `std` items like `Option` and `Iterator`, you might desugar `for x in items { ... }` into the following:

```rust
loop {
    match Iterator::next(items) {
        Some(x) => { /* ... */ },
        None    => break,
    }
}
```

But what if a user defines those names locally? Any of `Some`, `None`, and `Iterator` could potentially resolve to anything.

Ok, new plan: desugar to use the full `std` paths for each item.

```rust
loop {
    match std::iter::Iterator::next(items) {
        std::option::Option::Some(x) => { /* ... */ },
        std::option::Option::None    => break,
    }
}
```

This _is_ better... but what if the user defines a submodule called `std` that contains these paths? Essentially, our problem is that there's no way to write names for these items that a user cannot redefine locally.

In Rust, the solution is to use **lang items**: these are basically compiler intrinsics that bypass ordinary name resolution and immediately resolve to items in `core`[^1]. Even if the prelude isn't in scope, and `std` is inaccessible in the ordinary way, lang items guarantee that otherwise correct code can still compile.

The complete desugar then looks like the following in HIR:
```rust-hir
loop {
    match #[lang = "next"](&mut iter) {
        #[lang = "Some"] { 0: _ } => { /* ... */ },
        #[lang = "None"] {} => break,
    }
}

```

## In Jabber
Obviously, I'm not in the business of actually producing the world's most robust compiler: patch jobs are fine for a bachelor's project. But it is useful to keep in mind that, when desugaring to a high-level IR, name resolution probably shouldn't be relied upon. Certainly for the operators, which will desugar into invocations of functions in the core library, it's critical that they don't break in the presence of a newly defined `add` function or something.


# Compiler Architecture

CST ------------> AST ---------------> HIR -------------> SCM --------------> Scheme ---------> ...
     desugaring    ^   type-checking    ^     codegen            rendering                       ^
                   |                    |                                                        |
             name-resolution     static analysis                                       compilation/packaging

Notes:
1. SCM is the compiler-internal Scheme IR.
2. Scheme compatibility is likely either R6RS or R7RS-Small.
3. In practice, static analysis occurs in both the AST and HIR phases.
4. Code errors are emitted in the CST, AST, and HIR phases.
5. Errors in all later phases are presumed not to be language related, since
    these should have been filtered out in the first three phases.

# Gleam's `todo` and `panic` Keywords
I had thought to add `todo` and `panic` keywords in the same vein as Gleam, with an eye to having "native" support for incompleteness. But this is unnecessary (kinda)! Gleam _has_ to distinguish `todo` and `panic` as special expressions because it doesn't have language level support for a bottom type.

One point, though: Rust and Gleam both use compiler magic (either with macros or a dedicated keyword) to generate a message at compile-time for `todo` and `panic` -- in particular, they both insert the textual location of the particular call that caused the program to panic. Since I'm not using macros, this is an impasse, and I either have to add the Gleam-style keywords or suffer a worse debugging experience.

To be fair: I _could_ just pretend `panic` is a function while giving it some compiler magic (minus the variadics), and then implement `todo` in terms of it. It'll just be an awkward hard edge in the language, since there would (presumably) be no way to configure the behaviour `panic` at compile time in the way that Rust does.

[^1]: My understanding is that most of the compiler magic is in `core`, whereas `std` is (mostly) just a normal crate.

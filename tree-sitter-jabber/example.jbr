#! a shebang line

//! A module comment

// a regular comment

use std.list
use std.list.List

use std.foo.bar.baz.SomeType

pub const PI: float = 3.14159263

/// A dynamically-sized buffer of bytes.
extern type ByteBuffer

@name.scheme("bytevector->list")
extern fn byte_buffer_to_list(buf: ByteBuffer) -> List[int]

@some.attribute(true, '\x00', "hello, world!")
mod foo
@unscoped_attr
mod bar
mod baz
mod qux

fn id(x) = x

pub fn callcall(f: A -> B -> C) = f(0, 1, 2)
fn constant(x: A) -> B -> A = (_: B) -> x

fn    head0(x :: _    : List[T]) -> T = x
fn   head1((x :: _)   : List[T]) -> T = x
fn  head2(((x :: _))  : List[T]) -> T = x
fn head3((((x :: _))) : List[T]) -> T = x

pub struct Ref[T] {
  mutable contents : T,
}

pub fn ref(contents: T) -> Ref[T] = Ref { contents }
pub fn deref(ref: Ref[T]) -> T = ref.contents
pub fn update(ref: Ref[T], new: T) {
  ref <- new;
}

pub fn foo() -> () {
  a();
  b();
  let __true  = !!true;
  let __false = !!false;
  let _: bool = c();
  let (x, y, z, w): (int, int, int, int) = (0xFF, 0x00, 0xAA, 0x33);
  let first = ((), 'a', 13.023, true, "world").1;
  let a: foo.bar.Ty[int] = b.c.d();
  let t = ((!!!false));
  let _ = 1.0 + 2 * 3;
  let _ = x
          |> f
          |> g;

  let foo = 1 :: 2 :: 3 :: [];
  let pi:  float =     3.14159265;
  let tau: float = 2 * 3.14159265;
}

/// A value which may be `Ok(T)` or `Err(E)`.
@core.lang_item
pub enum Result[T, E] {
  /// A value denoting a successful outcome.
  @core.lang_item
  Ok(T),
  /// A value denoting a failiure state.
  @core.lang_item
  Err(E),
}

pub type Always[T]    = Result[T, !]
pub type AlwaysErr[E] = Result[!, E]

fn nybl(value: int) -> std.option.Option[Nibble] {
    if value <= 0xFF {
        Some(Nibble(value))
    } else {
        None
    }
}

fn pats(list: List[T]) = match list {
  List.Nil => (),
  [] => panic(),
  [a, b, c] => todo(),
  a :: b :: c :: [] => todo(),
}

type Never = !
type Absurd[T] = ! -> T

pub enum Option[T] {
  Some(T),
  None
}

pub fn unwrap(opt: Option[T]) -> T = match opt {
  Option.None => panic("Tried to unwrap an Option.None"),
  Option.Some(x) => x,
}

pub fn map(opt: Option[T], f: T -> U) -> Option[U] = match opt {
  Option.None => Option.None,
  Option.Some(x) => Option.Some(f(x))
}

fn foo() = option.map(Some(3), x -> x^2)

fn foo_piped()
  = Some(3)
    |> (opt -> option.map(x -> x^2, opt))
    |> option.unwrap

fn foo_piped_pascal()
  = Some(3)
    |> (opt -> Option.map(x -> x^2, opt))
    |> Option.unwrap


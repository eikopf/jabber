# Name Resolution

Consider the following code snippet:

```jabber
use some.foo

type foo = int

fn foo(foo: foo) -> foo {
    let foo: foo = foo;
    let foo = foo + foo;
    foo
}
```

We should be able to rewrite it correctly into the following:

```jabber
use some.foo as __mod_foo

type __typealias_foo = int

fn __fn_foo(foo0: __typealias_foo) -> __typealias_foo {
    let foo1: __typealias_foo = foo0;
    let foo2 = foo1 + foo1;
    foo2
}
```

This is both ridiculous, _and_ should still be reasonable to resolve.

We have several kinds of names:
1. modules;
2. functions;
3. types;
4. values;
5. constants;
6. reserved names.

Reserved names are effectively a non-issue: if they are *ever* used to name
anything, then we just emit an error. In particular that means anywhere we
see the names `int`, `float`, `char`, `string`, or `bool`, we know that they
**must** refer to the corresponding types.

Of the other name groups, types are the easiest to deal with: they only appear
in a very particular set of locations, and so can never cause intractable name
collisions.

For the remaining names, we use shadowing semantics: a name always refers to
its most narrowly-scoped definition. How much we can infer depends heavily on
the relevant context.

In a use declaration, the non-terminal elements of a path may be either modules
or enum types, since the constructors of enum types are scoped "within" their
type. In practice we can say that enum declarations literally do create modules
named after themselves, and resolve accordingly.


# Attributes, Decorators, and Compiler Metadata
Basically every "real" language has some way to communicate additional information to the compiler: directives, pragmas, decorators, attributes, and others are all basically just ways to annotate semantic objects with metadata.

Though I want to avoid pulling _too_ much from Rust, I think that both the meta item syntax and inner/outer attribute distinction are ideas worth keeping. The actual syntax here is relatively unimportant, so long as it is easy to parse, and most importantly is distinguished from the core language.

# Rust's [Attributes](https://doc.rust-lang.org/stable/reference/attributes.html)
> For the sake of brevity, this discussion ignores macro attributes.

Rust divides attributes into _inner_ and _outer_ attributes, and provides a small language of **meta items** that can appear within them. Much of the attribute structure and syntax is modelled after C# as described in [ECMA-334](https://ecma-international.org/publications-and-standards/standards/ecma-334/) §22 and [ECMA-335](https://ecma-international.org/publications-and-standards/standards/ecma-335/) §II.5.9.

```ebnf
(* attributes *)

attribute = inner attribute | outer attribute ;
inner attribute = "#", "!", "[", attr, "]" ;
outer attribute = "#",      "[", attr, "]" ;

attr = simple path, [attr input] ;
attr input = delimited token tree | "=", expression ;
```

Attributes are not "extra" tokens (in the sense of comments and whitespace), and can appear only in specific locations; these are as follows:

Outer attributes may appear before
- item declarations;
- most statements;
- enum variants;
- struct and union fields;
- match expression arms;
- generic lifetimes and type parameters;
- some limited expressions;
- function, closure, and function pointer parameters.

Inner attributes may appear within
- external blocks;
- functions;
- implementations;
- modules;
- block expressions.

Note that because files are module blocks, inner attributes may appear in them (so long as they do not appear after top-level items).

```ebnf
(* meta items*)

meta item = simple path 
          | simple path, "=", expression
          | simple path, "(", [meta seq],  ")"
          ;

meta seq = meta item inner, {",", meta item inner}, [","] ;
meta item inner = meta item | expression ;
```

[A full list of built-in attributes](https://doc.rust-lang.org/stable/reference/attributes.html#built-in-attributes-index) is provided in the Rust reference; the following are some particularly notable examples:

- `test` marks functions as tests;
- `link` and `link_name` provide data for linking against native libraries;
- `doc` provides advanced controls for documentation comments;
- `panic_handler` marks a function as the global panic handler;
- `non_exhaustive` indicates that a type may have more fields or variants added in the future.

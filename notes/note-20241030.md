# Name Resolution: Problems & Architecture

Trying to get started on the name resolution portion of the compiler over the
past week or so has been _deeply_ frustrating, and I've churned over a huge
number of ideas without really getting anywhere.

But at this point I'm finally getting somewhere, so now is a good time to stop
and review what I'm doing.

## Architecture
The fundamental design of the `resolve::Resolver` struct revolves around two
interrelated processes. 

The first is the construction, maintenance, and usage of the `env::Env` struct,
which is basically a global database that the `Resolver` can interact with
using an exclusive reference. This design is inspired by a similar pattern in
[the Austral compiler](https://borretti.me/article/design-austral-compiler#env),
where the `env` type is basically just a barebones SQL database with several
tables. This design works quite well for me, though I'd like to provide some
way for the compiler to load cached data into the `Env`; this matters in
particular for memory management, since I really don't want to have all the
files in the entire dependency graph in memory simultaneously.

The second is the conversion from `ast::unbound::*` to `ast::bound::*`, which
is handled by the `Resolver` directly. For most AST nodes, there are
corresponding methods like e.g. 
`resolve_expr(&mut self, expr: unbound::Expr) -> ResResult<bound::Expr>`
that take an unbound AST node, resolve any names it may use, and return a
result indicating whether or not there were any issues that arose when trying
to resolve those names. Effectively, the `Resolver` has a bunch of methods to
convert fragments of the unbound AST into fragments of the bound AST.

## Related Problems
The big areas related to name resolution are package loading and locating.

Starting with locating, this should be (as much as possible) a problem for
the compiler's _driver_, in analogy with how `cargo` relates to `rustc`. The
public interface for name resolution should not try to manage package loading
or locating, and indeed it relies on the packages having been appropriately
ordered before it sees them.

Package loading encompasses a few different problems, including a great deal
of boring IO. But presuming we can locate packages, do some version solving,
and load them into memory, the next concern is that they need to be sorted
correctly.

Since the dependency graph always forms a DAG with `core` as the terminal
package, there must exist a topological ordering of the packages such that
no package appears before any of its dependencies. This means name resolution
can presume packages are correctly ordered, and therefore only has to deal
with out-of-order resolution within packages.

A more mundane problem in this direction is caching: given that we generally
expect only the root package to change frequently, how do we cache information
about previously-compiled packages such that the `Env` can treat them opaquely
like any other package? The solution probably involves something like Gleam's
`package_interface::*` types, but at the moment this is a less pressing issue.

## Other Resources
I've found that the `rustc_resolve` package in the Rust compiler has been very
useful for understanding the process of name resolution: the `jabber_core`
`resolve::{Res, Scope, ScopeKind}` types are loosely based on the `Res`, `Rib`,
and `RibKind` types respectively.

Also, some portions of the `package` module in `jabber_core` draw influence
from both the Rust and Gleam compilers. The `package::metadata` and 
`package::interface` modules reflect similar constructs in the Gleam compiler,
while the notion of a `package::loader` module draws from both Gleam and Rust;
I presume the Gleam compiler also draws this idea from `rustc` originally.

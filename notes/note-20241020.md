# Module Names & Legibility
A common convention in languages without methods (notably including Julia and
OCaml) is to write module names in `PascalCase`. This feels odd, especially
compared to the conventions of almost all other languages.

But there is a method to the madness! If your languages uses `PascalCase` for
module names, then you recover some of the legibility of method calls while
also being more explicit about the types you're working with.

Compare this example in OCaml:
```ocaml
let foo = List.map f [1, 2, 3]
```

Or this (contrived) example in Julia:
```julia
foo = Lists.map(f, [1, 2, 3])
```

To this example in Gleam:
```gleam
let foo = list.map(f, [1, 2, 3])
```

In dense code, I think the OCaml and Julia examples are much more legible than
the one in Gleam; they also make it clear that `List` is a module, not a local
value, whereas Gleam's `list` is less clear.

Of course this is all bikeshedding, and Gleam largely draws its conventions
from Rust. But I can't help but feel that those conventions were chosen for a
reason in Rust, and those reasons are less apparent for languages in this class
of type systems.

# Disambiguating Types and Modules
It's pretty common for modules to have a "primary type," and therefore to use
a very similar name. There are a few solutions for this:

1. OCaml uses a convention of `ModuleName.t`, where that `t` is an alias for
the primary type. It also helps that OCaml uses lowercase names for types.
2. Rust and Gleam use lowercase names for modules.
3. Julia has the weirdest convention: module names are often the pluralised
form of their types. You might define a `Result` type and put it in a `Results`
module, for example.

All these conventions circle around the same idea: modules and their types want
to use extremely similar names, and often the **exact** same name.

# Aliasing Rules for Jabber
So assuming that we make Jabber's modules and types use `PascalCase`, and we
want to use the same name for some modules and types, what are the relevant
rules? What is the relationship between aliased items?

Let's say we have a module `Core.List` and a type `Core.List.List`. We
import them both into the same namespace using `use Core.{List, List.List}`,
and we immediately have a problem: this syntax _sucks_.

Julia distinguishes between `import` and `using` statements, where `import`
provides precise control over which items are imported into the namespace,
while `using Module` statements import both `Module` itself *and* a defined
list of exported items. That second component is more a concession to the
reality of Julia as a REPL language, but the idea of a statement that imports
both the module itself as well as a few key items is particularly interesting.

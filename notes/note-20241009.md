# Learning From OCaml

## Mutable Struct Fields
Most functional languages provide escape hatches for mutability. Haskell and
related languages use a `Ref` type to preserve immutability with indirection,
while OCaml allows record fields to be marked as `mutable`.

Broadly, OCaml's solution is more performance friendly, but relies on its
strict evaluation semantics; the same trick would not work in Haskell. Still,
the `mutable` record field system is strictly more powerful than the opaque
`Ref` type solution, since one can just define a `'t ref` type as a record
with a single mutable member.

```ocaml
(* this is actually how ref is defined in the Core module *)
type 't ref = {
    mutable contents : 't;
}
```

At runtime, an `int ref` is a non-null pointer to a heap-allocated `int`. If
instead you inline the mutable field into the enclosing type, OCaml is able
to remove the indirection and treat that field like any other member of the
record.

OCaml defines three relevent operators for `ref` and `mutable` record fields:
1. `<-` updates the value of a mutable field; its type is unspellable.
2. `(!) : 'a ref -> 'a` is the dereference operator.
3. `(:=) : 'a ref -> 'a -> ()` is the update operator.

Of these, only `<-` is truly primitive. The choice of `!` as the dereference
operator is somewhat odd, but OCaml doesn't have a boolean `not` operator,
and so this doesn't really have a material impact. I'm inclined to use prefix
`*` in Jabber for the same operation, just because it's what's familiar to
users from C-family languages.

## Removing Ad-Hoc Polymorphism
One of problems that becomes obvious(-ish) when you totally drop ad-hoc
polymorphism in a statically typed language is how you then deal with the
numeric operators, like `+` and `-`.

For OCaml (and as inherited by Gleam), the solution is to radically shrink
the number of primitive numeric types to just two: `int` and `float`. Then,
you can treat the usual arithmetic operators as being `int -> int -> int`,
and add corresponding operators (suffixed with `.`, e.g. `+.`) which are
`float -> float -> float`.

In Jabber's case, some operators have to be removed (postfix `?` and `!`, as
well as `>>=` and `<=>`), while others need to have new versions defined for
`float`.

## Generating Equality Definitions
OCaml uses some compiler magic to generate an implementation of structural
equality for every type, and so the type of `=` is `'a -> 'a -> bool`, even
though most other functional programming languages would consider this to
be a type error.

In the formal sense (I think), OCaml's type system is a regular category of
types in which for every type `t` there is a morphism `t * t -> bool`. This
isn't too odd; we generally assume a notion of equality between objects, but
it is interesting that the notion of equality itself can be embedded in
categories of types.

OCaml _also_ has a second notion of **physical** equality for types which are
not referentially transparent, but I don't think it's worth including something
similar in Jabber.

Maybe users should be able to opt-in for the `==` operator rather than out? If
you're not careful, computing structural equality for recursive types can be
very expensive; it would be nice to explicitly remove the operator for some
types. But then the signature `(==) : (T, T) -> bool` would be a lie, since
there would be some types for which equality is undefined.

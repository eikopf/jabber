/// this is an ungrammar for the FYP language, which represents its
/// structure in terms of syntax trees rather than sequence of tokens

/// ref: https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html

File = (AccessSpec? Decl)*

Decl = AccessSpec? DeclBody

AccessSpec = 'pub'

DeclBody =
  ModDecl
| UseDecl
| StructDecl
| EnumDecl
| SigDecl
| FnDecl

ModDecl = 'mod' Ident
UseDecl = 'use' Name ('as' Ident)?

StructDecl = 'struct' Ident GenericParams? '{' StructFields? '}'
StructFields = StructField (',' StructField)* ','?
StructField = Ident ':' TypeExpr

EnumDecl = 'enum' Ident GenericParams? '{' EnumVariants? '}'
EnumVariants = EnumVariant (',' EnumVariant)* ','?
EnumVariant = Ident EnumPayload?
EnumPayload = '(' TypeExpr (',' TypeExpr)* ','? ')'

GenericParams = '<' Ident (',' Ident)* '>'

SigDecl = 'sig' Ident ':' FnTypeExpr

FnDecl = 'fn' Name FnParams? ('->' TypeExpr)? ('=' Expr | BlockExpr)
FnParams = '(' (FnParam (',' FnParam)* ','?)? ')'
FnParam = Pattern ':' TypeExpr

Expr =
  Name
  LiteralExpr
| ListExpr
| TupleExpr
| StructExpr
| FieldExpr     // struct field access
| LambdaExpr    // anonymous functions
| CallExpr
| OpExpr
| MatchExpr
| IfElseExpr
| BlockExpr
| '(' Expr ')'

LiteralExpr =
  'true'
| 'false'
| CharLiteral
| StringLiteral
| IntLiteral
| FloatLiteral

ListExpr  = '[' SeqExprContents? ']'
TupleExpr = '(' SeqExprContents? ')'
SeqExprContents = Expr (',' Expr)* ','?

StructExpr = Name '{' StructExprFields? '}'
StructExprFields = StructExprField (',' StructExprField)* ','?
StructExprField = Ident (':' Expr)?

FieldExpr = Expr '.' Ident

LambdaExpr = (Ident | '(' LambdaParams? ')') '->' Expr
LambdaParams = LambdaParam (',' LambdaParam)* ','
LambdaParam = Pattern (':' TypeExpr)?

CallExpr = Expr '(' CallExprParams? ')'
CallExprParams = Expr (',' Expr)* ','?

OpExpr =
       PrefixOp  Expr
| Expr InfixOp   Expr
| Expr PostfixOp

PrefixOp  = '!' | '+' | '-'
PostfixOp = '?' | '!'
InfixOp   = ArithOp | BitOp | CmpOp | FnOp | LazyOp

ArithOp = '+' | '-' | '*' | '/' | '^' | '%'
BitOp   = '&' | '|' | '~' | '<<' | '>>'
CmpOp   = '<=>' | '==' | '!=' | '>' | '<' | '>=' | '<='
FnOp    = '$' | '|>' | '>>='
LazyOp  = '||' | '&&'

// the MatchArms are optional because the scrutinee might
// evaluate to an uninhabited type (like !).
MatchExpr = 'match' Expr '{' MatchArms? '}'
MatchArms = MatchArm (',' MatchArm)* ','?
MatchArm  = Pattern ('if' Expr)? '=>' Expr

IfElseExpr = 'if' Expr BlockExpr ('else' BlockExpr)?

BlockExpr = '{' BlockExprBody? '}'
BlockExprBody = Stmt (';' Stmt)* ';'?

Stmt =
  ';'
| Expr
| LetStmt

LetStmt = 'let' Pattern (':' TypeExpr)? '=' Expr

Pattern =
  Ident                                 // binding
| '_'                                   // wildcard
| '..'                                  // rest
| '(' SeqPatternContents? ')'           // tuple
| '[' SeqPatternContents? ']'           // list
| Pattern '::' Pattern                  // cons
| Name EnumPatternPayload?              // enum
| Name '{' StructPatternFields? '}'     // struct
| LiteralExpr                           // literal

SeqPatternContents = Pattern (',' Pattern)* ','?

EnumPatternPayload = '(' Pattern (',' Pattern)* ','? ')'

StructPatternFields = StructFieldPattern (',' StructFieldPattern)* ','?
StructFieldPattern = Ident (':' Pattern)? | '..'

TypeExpr =
  '!'
| '()'
| 'bool'
| 'char'
| 'string'
| 'u8'
| 'u16'
| 'u32'
| 'u64'
| 'usize'
| 'i8'
| 'i16'
| 'i32'
| 'i64'
| 'isize'
| 'f32'
| 'f64'
| '(' TypeExpr (',' TypeExpr)* ')' // tuple type
| '(' TypeExpr ')' // parenthesized type, has precedence over tuple
| Name GenericArgs?
| FnTypeExpr
| '_'   // the inference placeholder

GenericArgs = '<' TypeExpr (',' TypeExpr)* ','? '>'

FnTypeExpr = '(' FnTypeArgs? ')' '->' TypeExpr
FnTypeArgs = FnTypeArg (',' FnTypeArg)* ','?
FnTypeArg  = (Ident ':')? TypeExpr

/// note: a name is a qualified list of idents separated by the '::' digraph,
/// while an ident is just a single valid identifier. names are a superset of
/// idents.
Name  = 'name'
Ident = 'ident'

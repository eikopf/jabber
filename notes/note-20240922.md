# Primitive Types

Designing the set of primitive types for Jabber feels like choosing a basis for a vector space: I definitely need to span the entire space, but redundancy is a concern with too many basis vectors.

So, some guiding design goals:

1. Preserve the distinction between signed and unsigned integers.
2. Provide both fixed-width and unbounded integral types.
3. Define canonical primitives for the "trivial types."
4. Maintain a clear separation between primitive and composite types.

Regarding (3), there are some obvious basics:

- `char` and `string` as the lexical UTF-8 basics;
- `bool` as the canonical binary choice type;
- `()` as the canonical identity value for products;
- `!` as the canonical identity value for coproducts.[^1]

Presuming collection types are left to the standard library, we now only have to consider the primitive numeric types. I'm happy to leave the architecture-dependent C types as `extern type` declarations in an FFI module, so that only leaves floats, fixed-width integers, and unbounded integer types.[^2]

1. The fixed-width types will match Rust's fixed-width integers (excluding `u128` and `i128`); hence these are `u8`, `u16`, `u32`, `u64`, `i8`, `i16`, `i32`, and `i64`.
2. Rust's architecture-dependent integers (`usize` and `isize`) can be roughly modelled by `uint` and `int` types, but these will have a smaller minimum bitwidth based on the architecture.
3. The unbounded integral types will be roughly equivalent to Idris' `Integer` and `Nat` types, and probably be called `bigint` and `biguint` respectively.
4. The floating-point types will correspond exactly to the usual IEEE-754 types: `f32` and `f64`.

Some open questions:
- What about pointers and references? I'm currently leaning towards them being composite types with some compiler magic.
    - Idris models its `Ptr t` and `AnyPtr` types as C `void*` values, ([source](https://idris2.readthedocs.io/en/latest/ffi/ffi.html#primitive-ffi-types)) and the type variable in the `Ptr` definition is a phantom type parameter.
- What are the overflow/underflow semantics for the fixed-width and architecture-dependent types?
- Should `int` be a valid FFI type? It would make interop much easier, though perhaps it would be too much of a restriction.


[^1]: In this sense, `!` (never), `()` (unit), and `bool` are the canonical type equivalents to `0`, `1`, and `2`. Users probably shouldn't have to define isomorphic equivalents for these types.

[^2]: A more complete language would probably also provide decimal and rational types, as well as dedicated infrastructure for defining some more exotic types (like `bf16`).
# Type System Modifications

## Removing The 1-Tuple
For any type `T`, the isomorphism `T ≅ (T,)` is trivial and obvious. In OCaml,
the `*` type operator prevents the 1-tuple type from being written. In Idris,
tuples are right-nested pairs, so must have at least two elements.

Suppose Jabber followed Idris' example. I think this is fine, but it raises an
awkward edge case: the unit type `()` is notated as the 0-tuple, and so this
accentuates the absence of the 1-tuple. Any documentation should probably note
this explicitly for the user.

## Tuples as Right-Associative Pairs
Returning to the Idris case, consider the inclusion of typeclasses (Idris calls
them interfaces). In Rust and Haskell, one runs into the problem of _variadic
generics_, where you need to provide separate typeclass instances for each
k-tuple. But in Idris, an instance like `instance (Ord a, Ord b) => Ord (a, b)`
permits the typeclass solver to inductively apply this instance to all k-tuples
with k ≥ 2.

In Prolog-ish notation for k = 3:
`Ord (a, b, c) ⊢ (Ord a, Ord (b, c)) ⊢ (Ord a, Ord b, Ord c)`

As an aside, the fact that languages like OCaml _don't_ make their `*` operator
associative is unintuitive: it gives that the types `a * a * a`, `(a * a) * a`,
and `a * (a * a)` are all distinct despite being isomorphic. Actually, this
means OCaml's `*` isn't really a proper binary operator in the way that the
type-theoretic product operator `×` is.

## Explicit Type Variables
Because OCaml has neither the explicit type variable introduction syntax of
Rust, or the `forall` operator of Haskell, it's possible for names in scope
to clobber type variables.

OCaml's solution to this problem is to permit the apostrophe (`'`) to appear
before identifiers in types, to explicitly indicate that the identifier is a
type variable rather than an unscoped item.

```ocaml
(* we have a local type synonym `a` *)
type a = int

(* `'a` is explicitly distinct from `a` *)
let safe_id (x : 'a) = x

(* whereas here, `a` resolves to `int` *)
let clobbered_id (x : a) = x

```

## What Actually Is ⊥, Anyways?
There are two broad interpretations for the bottom type:

1. In the OO world, it is the universal subtype.
2. In the FP world, `∀ t : Type => ⊥ : t`; that is, ⊥ is a member of all types.

Interpretation (2) is cleaner, since we avoid having to define a proper subtype
relation, and can instead view every type expression `T` as being a shorthand
for `T + ⊥`.

This also justifies the unification of ⊥ with all other types, since it is
"already a member of all other types" (scarequotes intended, this is _very_
informal).

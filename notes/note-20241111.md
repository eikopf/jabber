# I Have Never Hated Anything More Than Name Resolution

New problem: ambiguities!

Under the existing rules, terms and types can have the same name because they
occupy different namespaces. This was a rule borrowed from OCaml, where e.g.
the name `ref` is used for both the function and the type.

But it is _literally_ impossible to use a name in OCaml without somehow using
it as either a term or a type, so this doesn't cause issues. By contrast, how
do you disambiguate a freestanding import? It doesn't necessarily have a usage
site, so you just can't decide whether the user is referring to the term or the
type.

My solution here is to remove the namespace distinction: terms and types cannot
have the same name, and struct (singular) constructors are a special case of
syntax sugar.

This makes all paths unambiguous: we can always judge whether a path is
well-formed, and we can always resolve well-formed paths to their declarations.
Special handling is needed for the struct constructor case, where we resolve to
a `TypeId` with a wrapper type indicating that it can be used as both a term
and a type.

# An Inside-Out Name Resolution Architecture

One of the driving goals in the architecture of the compiler is to produce good
error messages, and to report as many errors up-front as possible. If the user
makes a syntax error within the body of a function somewhere, that shouldn't
prevent the compiler from reporting errors from elsewhere in the program or
later in the pipeline.

Name resolution is a compiler stage that benefits from this "wide" approach to
errors, since there are a variety of subtly different ways that a name can fail
to resolve.

Name resolution will proceed in three distinct stages:
1. module name resolution;
2. package name resolution;
3. global name resolution.

The first two stages can produce _requirements_ that must be satisfied by later
stages, and the third stage will be able to produce an error for outstanding
requirements that it cannot satisfy.

## Requirements
A requirement is a symbol that source code references, but whose existence
cannot be verified in the current stage. There are three distinct kinds of
requirement:

1. A _local_ requirement is an unqualified reference to a symbol which must
be in scope. These requirements can only be resolved by glob imports, since
this is the only way for an unwritten name to be in scope.
2. A _package_ requirement is a qualified reference to a symbol in the current
package, but not in the current module. `super` and `package` qualified symbols
are obvious examples. These requirements can always be resolved in the package
name resolution stage
3. A _global_ requirement is a qualified reference to a symbol in a different
package. These cannot be resolved until the final stage.

All requirements are emitted during the first stage of name resolution, and the
latter two stages exist to resolve different kinds of requirements.

Special handling is required for glob imports, since in general they cannot be
resolved and checked until the global name resolution stage.

## Ownership & Paralellisation
This architecture is an obvious candidate for parallelisation, since the first
and second stages can happen concurrently across the entire dependency graph.
In practice, this means there will be many more smaller allocations made over
using a single central allocation. This also introduces concerns about lock
contention over `Uid::fresh()` invocations, so that module might need to be
rewritten.

These are future concerns, and the first MVP for this system should not be
parellelised.

## Glob Imports
Glob imports are a uniquely complex concern in this area, so we will treat them
separately. This doesn't really include glob type constructor imports, since
they can be resolved as soon as we know that the glob import source is a type.

When resolving a module, glob imports make local name resolution harder, since
a name can be referenced even if it is not literally present in the source. In
effect, a glob import adjoins an unknown symbol table to a module's symbol
table, and so we simply cannot deal with glob imports until that unknown table
is encountered and processed.

If there are multiple glob imports in a module, then we also need to ensure
that there are no duplicate names among those glob imports. Unless all the
glob imports are package-local, we must wait until the global name resolution
stage to process them.

## Module Name Resolution
Each module is resolved independently in this stage, and any names that cannot
be resolved are converted into requirements.

As declarations are encountered, they are processed into their `ast::bound`
equivalents, potentially emitting requirements in the process. Requirements
should be unified where possible, but alias imports should be preserved in case
they need to be printed in an error. Throughout the entire process we must
check for duplicate names and report them as errors.

Local declarations can be used to satisfy local requirements, though we may not
discharge all local requirements in this stage if there are glob imports in
scope.

There are a variety of small errors (duplicate imports, duplicate type 
constructor names, etc.) that can be reported in this stage, but if they
aren't fatal then we should keep going.

# Remaining Design Questions
At this point, I have most of the design for Jabber in place; there are a
few key questions that remain, however.

## Function Types
It turns out I didn't really put enough thought into *why exactly* Gleam
and Rust use the `fn` keyword to mark function types. That is, consider
the following type:

```
type Foo[A, B] = (A, B) -> () 
```

Okay, great, it's a function type. New question: what arguments does it take?

Either this is a function of two arguments `A` and `B`, or a function of one
argument `(A, B)`. And since autosplatting seems like a soundness blackhole,
that distinction matters.

The Rust/Gleam solution is to reuse the `fn` keyword: the above type could be
properly rendered as the following type:

```
type Foo[A, B] = fn(A, B) -> ()
```

This raises another question: is `A -> B` a valid function type? Or would a
user have to write `fn(A) -> B` instead? It's the difference between these two
renderings of a `Pred[T]` type synonym:

```
type Pred[T] = fn(T) -> bool

// OR

type Pred[T] = T -> bool
```

Or these two `map` implementations on `Option`:

```
fn map(opt: Option[A], f: fn(A) -> B) -> Option[B] = ...

// OR

fn map(opt: Option[A], f: A -> B) -> Option[B]
```

This syntax does degrade for larger function types, however:
```
type Abcd = fn(A) -> fn(B) -> fn(C) -> D

// OR

type Abcd = A -> B -> C -> D
```

But it's also worth taking a look at Scala, since it's probably the most
prominent example of an uncurried-by-default functional language.

Scala's function types behave in the same way that my original design
called for: arguments are written in a tuple, but are presumed to denote
higher-arity functions rather than unary functions of tuples. If a function
*is* unary, then the parentheses and commas can be elided.

The obvious question: namely, "How do you write the 1-tuple?" is answered
simply: you don't. Scala doesn't have trailing commas in the syntax, and
the `Tuple1` constructor is provided for completeness. There's also a cultural
attitude in the Scala world that tuples should be treated like cartesian products,
and so the 1-tuple is seen to be pointless.

This is quite similar to what Idris does: the syntax `(x,)` expands to the
function `\y => (x, y)` (mostly), and tuples are realized as pairs nested in 
the right argument (e.g. `(a, b, c)` is the same as `(a, (b, c))`).

I **think** (though this could change) that the existing Scala example is enough
evidence to justify the current syntax. If a user actually wants to define a unary
function that takes a tuple, this can be done by wrapping the tuple in `(<TUPLE>,)`.

## Ad-hoc Polymorphism
One of the potential pain points for this project relates to any potential
implementation of ad-hoc polymorphism; currently this is the `sig`/`where`
constructs in the syntax.

The practical difficulty in this kind of implementation is that it can very
quickly spiral in complexity. For example, Rust's trait system uses a custom
logic programming system for trait solving, but still struggles with some
pathological edge cases involving coinduction. GHC's situation is worse:
Haskell does not enforce global coherence, and so a compiler must first verify
local coherence for any given module.

In general such systems are isomorphic to logics, and the minimal implementation
still essentially requires a weak FO-logic solver.

I presume the system for Jabber would not deal with negation or the existential
quantifier (∃) so the problem is reduced to atoms, propositions, implication, and
the universal quantifier (∀). Implementing a logic solver of this kind would
be feasible, but I'm unsure whether it would be a waste of my time relative to
other goals.

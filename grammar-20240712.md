# Prototype Grammar (2024-07-12)
This is a modified version of the first grammar sketch in the `org` notes, with some changes that became necessary while working on the prototype parser. Further, this version of the grammar also includes whitespace rules and clears up some ambiguities that were present in the first version.

```ebnf

literal = "true"
        | "false"
        | "()"
        | numeric_literal
        | char_literal
        | string_literal
        | seq_literal
        | func_literal
        | struct_literal
        | name
        ;

(*
    in an actual parser implementation, it's probably better to admit
    some malformed numeric literals (like 0.3u32); it's nicer to emit
    an actual error message rather than "failed to parse <filename>."
*)

numeric_literal = integer_literal
                | float_literal
                ;

integer_literal = dec_literal
                | bin_literal
                | oct_literal
                | hex_literal
                ;

float_literal = dec_literal "."
              | dec_literal "." dec_literal [ float_type ]
              | dec_literal [ "." dec_literal ] float_exponent [ float_type ]
              ;

float_exponent = ("e" | "E") [("+" | "-")] {( dec_digit | "_" )} dec_literal ; 

dec_literal =                            dec_digit {( dec_digit | "_" )} ;
bin_literal = "0b" {( bin_digit | "_" )} bin_digit {( bin_digit | "_" )} ;
oct_literal = "0o" {( oct_digit | "_" )} oct_digit {( oct_digit | "_" )} ;
hex_literal = "0x" {( hex_digit | "_" )} hex_digit {( hex_digit | "_" )} ;

bin_digit = "0" | "1" ;
oct_digit = bin_digit | "2" | "3" | "4" | "5" | "6" | "7" ;
dec_digit = oct_digit | "8" | "9" ;
hex_digit = dec_digit 
          | "a" | "b" | "c" | "d" | "e" | "f"
          | "A" | "B" | "C" | "D" | "E" | "F"
          ;

(*
    this is the most incomplete part of the grammar. what about
    raw strings? interpolation strings? explicit unicode scalar
    values? escape characters? the best path here is probably
    to follow rust's example.
*)

char_literal = "'" (textual_char | escaped_char) "'" ;
textual_char = ? a single character matching the regex [^'\\\n\r\t] ? ;
escaped_char = "\'"
             | '\"'
             | "\n"
             | "\r"
             | "\t"
             | "\\"
             | "\0"                         (* null byte *)
             | "\x" oct_digit hex_digit     (* ascii byte *)
             ;

string_literal = '"' {(textual_string_char | escaped_char | string_continue)} '"' ;
textual_string_char = ? a single character matching the regex [^"\\\r] ? ;
string_continue = ? a character sequence matching the regex \\\n ? ;

(*
    sequence literals can be treated as lists or vectors based on the
    inferred type, but the term "seq" is used to be type-agnostic by
    default.
*)

seq_literal = "[" skip { expr skip "," skip } [ expr skip [","] ] skip "]" ;

(*
    function literals follow the java/julia pattern, where parentheses
    are necessary for multiple parameters and type annotations.
*)

func_literal = func_literal_params skip "=>" skip expr ;
func_literal_params = param
                    | "(" skip { param skip "," skip } [ param skip [","] ] skip ")"
                    ;

(* 
    this type grammar borrows from haskell's grammar, which
    explicitly distinguishes between "atypes" and "btypes" to
    make parsing unambiguous and the "->" operator right-associative
*)

type = type_elem skip "->" skip type
     | type_elem
     ;

type_elem = integral_type
          | float_type
          | "bool"
          | "char"
          | "string"
          | "!"                         (* bottom, i.e. ⊥ *)
          | "()"                        (* unit *)
          | name [ generic_params ]     (* a custom composite type *)
          | "(" skip types2 skip ")"    (* a tuple with ≥2 types *)
          | "(" skip type   skip ")"    (* a parenthesized type *)
          | "_"                         (* inferred type *)
          ;

generic_params = "[" skip types1 skip ["|" skip types1 skip] "]" ;

types0 = { type skip "," skip } [ type ] ;          (* ≥0 types *)
types1 = type skip { "," skip type skip } [","] ;   (* ≥1 types *)
types2 = type skip "," skip types1 ;                (* ≥2 types *)

integral_type = ("i" | "u") ("8" | "16" | "32" | "64") ;
float_type = "f" ("32" | "64")

name  = ident { "::" ident } ;
ident = ? a string matching (_+[a-zA-Z0-9]|[a-zA-Z])[_a-zA-Z0-9]* ? ;

skip  = ? optional whitespace  ? ;
skip1 = ? mandatory whitespace ? ;
```

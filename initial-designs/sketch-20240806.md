This is a rough sketch for some syntax ideas around generics, primarily as a constrained form of Julia's function system. Some syntax choices are heavily inspired by OCaml --- this is particularly obvious in the `sig` keyword.

```
// function signatures
sig head : Q<A> -> A
sig tail : Q<A> -> Q<A>
sig pop  : Q<A> -> (A, Q<A>)

// generic function instances
fn head = first  . pop
fn tail = second . pop

// the type of this instance of head is basically as follows:
// forall Q. forall A. exists p ∈ pop. p : Q<A> -> (A, Q<A>). Q<A> -> A
//
// that is, we infer Q : * -> * and A : *, and say that this instance
// is applicable for them if there exists an instance of pop

// interface formed from a set of function requirements
class Queue<T> = {
  // Self = Queue<T> in this block
  head : Self -> T,
  tail : Self -> Self,
  pop  : Self -> (T, Self),
}

// then we can "implement" Queue for List

pop(list: List<A>) = match list {
  []      => panic("tried to take the first element from an empty list"),
  x :: xs => (x, xs)
}

// the definition of pop for List type checks because of the signature of panic
sig panic : A -> !

// ! is the name of the bottom type (i.e. ⊥), which unifies with all
// other types; in practice it means "this function does not return"

// at this point, List is already a Queue: there's no need to opt in.
// so we could write a signature and instance like this:

sig take_two : Q<A> -> (A, A, Q<A>)

take_two(queue: Queue<A>) = {
  let (first,  tail) = pop(queue);
  // new identifier shadows the earlier one
  let (second, tail) = pop(tail);
  (first, second, tail)
}

// and this function could be called on any List, e.g.
// (1, 2, [3, 4, 5]) ≡ take_two([1, 2, 3, 4, 5])

// this is the important point: because interfaces aren't opt-in,
// they function more like sets.
```

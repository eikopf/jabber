# Changes
1. Remove currying, which implies (2).
1. Change signature syntax to be uncurried; e.g.
    ```
    // this old signature
    sig map : (A -> B) -> F[A] -> F[B]
    
    // becomes this new signature
    sig map : (A -> B, F[A]) -> F[B]

    // probably, we should allow the parenthese to be omitted for unary
    // signatures; consider the following examples

    // without this syntax sugar, the type would be (()) -> R
    sig rng : () -> R

    // without this syntax sugar, the type would be (A) -> A
    sig id : A -> A // yes, this is obviously a stupid signature
    ```

1. Add a `mut` keyword for `let mut` variable bindings and `mut t: T` parameters, which implies the following new rules:
    1. Types that are "trivially copyable" (in the sense of Rust's `Copy`) always have value semantics, even when they are mutable; in particular this includes all primitive types except `string`.
    1. For all composite types `T` (including `string` and tuple types), the immutable version of `T` has value semantics, while `mut T` has reference semantics.[^1]
    1. A closure which captures a mutable variable is also mutable itself, and its type is given by `mut (<params>) -> T`.
        1. Notice that this is contravariant with respect to the ordering of non-function types: you can pass a `mut T` to a `T` parameter safely, while passing a `mut A -> B` to a `A -> B` parameter could potentially call, and therefore __mutate__, the given closure.
        1. The solution is to flip the ordering, and allow "immutable" closures to be passed to mutable function arguments, since they can only be called.[^2]
1. Replace `def` with distinguished `fn` and `impl` keywords, where:
    1. `fn` introduces a new function without a corresponding signature;
    1. `impl` introduces a new implementation for a predefined signature.

# Questions
1. How do we denote functionally dependent types in signatures? Do they have a glyph or a keyword? Should this be given in a `where` clause?

[^1]: This behaviour follows in the vein of languages like Janet and Julia, though both of these view mutable types as unrelated to their (purely nominal) immutable counterparts.

[^2]: This corresponds to the `FnMut <: Fn` trait hierarchy in Rust, and reflects the odd property that closures are basically blackboxes with a single method (i.e. implementors of SAM interfaces/traits).
